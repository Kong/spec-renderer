<template>
  <div
    class="request-sample-wrapper"
    :data-testid="`request-sample-${data.id}`"
  >
    <CollapsablePanel
      :collapsible="false"
      :content-to-copy="(requestCode as string)"
    >
      <template #header>
        <div class="select-wrapper">
          <SelectDropdown
            :id="`language-select-${data.id}`"
            v-model="selectedLang"
            class="language-selector"
            :items="requestConfigsSelectItems"
          >
            <template #shell-item-content="{ item }">
              <LanguageIcon lang="bash" />
              {{ item.label }}
            </template>
            <template #python-item-content="{ item }">
              <LanguageIcon lang="python" />
              {{ item.label }}
            </template>
            <template #node-item-content="{ item }">
              <LanguageIcon lang="node" />
              {{ item.label }}
            </template>
            <template #javascript-item-content="{ item }">
              <LanguageIcon lang="javascript" />
              {{ item.label }}
            </template>
            <template #go-item-content="{ item }">
              <LanguageIcon lang="go" />
              {{ item.label }}
            </template>
            <template #java-item-content="{ item }">
              <LanguageIcon lang="java" />
              {{ item.label }}
            </template>
            <template #ruby-item-content="{ item }">
              <LanguageIcon lang="ruby" />
              {{ item.label }}
            </template>
          </SelectDropdown>
          &nbsp;
          <!-- TODO: use SelectDropdown here when we start supporting libraries -->
          <select
            v-if="selectedLangLibraries.length"
            v-model="selectedLangLibrary"
          >
            <option
              v-for="lib in selectedLangLibraries"
              :key="lib.httpSnippetLibrary"
              :value="lib.httpSnippetLibrary"
            >
              {{ lib.label }}
            </option>
          </select>

          <SelectDropdown
            v-if="requestSamplesSelectOptions && requestSamplesSelectOptions.length && selectedRequestSample"
            :id="`request-sample-select-${data.id}`"
            v-model="selectedRequestSample"
            class="request-sample-selector"
            :items="requestSamplesSelectOptions"
            placement="bottom-end"
          />
        </div>
      </template>
      <!-- body -->
      <RequiredToggle
        v-if="hideTryIt"
        v-model="excludeNotRequired"
        :data="data"
      />
      <div class="wide">
        <CodeBlock
          v-if="requestCode && selectedLang"
          :code="(requestCode as string)"
          :lang="selectedLang"
        />
      </div>
    </CollapsablePanel>
  </div>
</template>

<script setup lang="ts">
import { watch, ref, computed, inject } from 'vue'
import type { PropType, Ref } from 'vue'
import type { IHttpOperation, INodeExample } from '@stoplight/types'
import { HTTPSnippet } from 'httpsnippet'
import { requestSampleConfigs } from '@/constants'
import { getRequestHeaders, getFormattedBody } from '@/utils'
import CodeBlock from '@/components/common/CodeBlock.vue'
import CollapsablePanel from '@/components/common/CollapsablePanel.vue'
import type { LanguageCode } from '@/types/request-languages'
import type { HarRequest, HTTPSnippet as HTTPSnippetType, TargetId } from 'httpsnippet'
import SelectDropdown from '@/components/common/SelectDropdown.vue'
import LanguageIcon from '@/components/common/LanguageIcon.vue'
import type { SelectItem } from '@/types'
import RequiredToggle from '../try-it/RequiredToggle.vue'


const props = defineProps({
  data: {
    type: Object as PropType<IHttpOperation>,
    required: true,
  },
  /**
   * server url selected by user on endpoints detail page
   */
  serverUrl: {
    type: String,
    required: true,
  },
  /* value is coming from TryIt path parameter change */
  requestPath: {
    type: String,
    required: true,
  },
  /* headers generated by auth token changes un TryItAuth */
  authHeaders: {
    type: Array as PropType<Record<string, string>[]>,
    default: () => [],
  },
  customHeaders: {
    type: Array as PropType<Record<string, string>[]>,
    default: () => [],
  },
  /* query portion generated by auth token changes un TryItAuth */
  authQuery: {
    type: String,
    default: '',
  },
  /* value is coming from TryIt query parameter change */
  requestQuery: {
    type: String,
    default: '',
  },
  /* value is coming from TryIt body parameter change */
  requestBody: {
    type: String,
    default: '',
  },
})

const excludeNotRequired = defineModel({
  type: Boolean,
  default: true,
})

const hideTryIt = inject<Ref<boolean>>('hide-tryit', ref(false))

const emit = defineEmits<{
  (e: 'request-body-sample-idx-changed', samlpleIdx: number): void
}>()

const requestConfigs = computed(() => {
  if (!hideTryIt.value) {
    return requestSampleConfigs.filter(c => c.httpSnippetLanguage !== 'json')
  }

  // when we have tryIt section is hidden, we want to show JSON choice when we have a body
  if (props.requestBody && hideTryIt.value) {
    return requestSampleConfigs
  }

  // in all other cases we filter json out
  return requestSampleConfigs.filter(c => c.httpSnippetLanguage !== 'json')
})

const requestConfigsSelectItems = computed(() => {
  return requestConfigs.value.map(c => ({
    label: c.label,
    value: c.httpSnippetLanguage,
    key: c.httpSnippetLanguage,
  }))
})

const selectedLang = ref<LanguageCode>()

const selectedLangLibrary = ref<string>()

const selectedLangLibraries = computed(() => {
  if (selectedLang.value) {
    return requestSampleConfigs.find(lang => lang.httpSnippetLanguage === selectedLang.value)?.libraries || []
  } else {
    return []
  }
})

const getFirstSampleKey = (examples: INodeExample[]): string | null => {
  if (Array.isArray(examples) && examples.length) {
    return examples[0].key
  } else {
    return null
  }
}

const selectedRequestSample = ref<string | null>(props.data?.request?.body?.contents && props.data.request.body.contents.length ? getFirstSampleKey(props.data.request.body.contents[0].examples as INodeExample[]) : null)

const requestSamples = computed((): INodeExample[] => {
  if (props.data?.request?.body?.contents && props.data.request.body.contents.length &&
    Array.isArray(props.data.request.body.contents[0].examples) &&
    props.data.request.body.contents[0].examples.length) {
    return props.data.request.body.contents[0].examples as INodeExample[]
  } else {
    return []
  }
})

const requestSamplesSelectOptions = computed((): Array<SelectItem> => {
  return requestSamples.value.map(s => ({
    label: s.key,
    value: s.key,
    key: s.key,
  }))
})

watch(requestSamples, (newValue: INodeExample[]) => {
  selectedRequestSample.value = getFirstSampleKey(newValue)
})

const snippet = ref<HTTPSnippetType>()

const requestCode = ref<string | string[] | null>()

watch(selectedRequestSample, (sampleKey) => {
  // firing the index of example user selects.
  emit('request-body-sample-idx-changed', (requestSamples.value as INodeExample[]).findIndex(s => s.key === sampleKey))
})

watch(() => ({
  method: props.data.method,
  lang: selectedLang.value,
  lib: selectedLangLibrary.value,
  serverUrl: props.serverUrl,
  authHeaders: props.authHeaders,
  customHeaders: props.customHeaders,
  requestPath: props.requestPath,
  requestQuery: props.requestQuery,
  authQuery: props.authQuery,
  requestBody: props.requestBody,
}), (newValue, oldValue) => {

  if (newValue.method !== oldValue?.method && requestConfigs.value?.[0]) {
    selectedLang.value = requestConfigs.value[0].httpSnippetLanguage
    newValue.lang = selectedLang.value
  }

  if (newValue.lang !== oldValue?.lang) {
    selectedLangLibrary.value = selectedLangLibraries.value?.length ? selectedLangLibraries.value[0].httpSnippetLibrary : undefined
  }

  let snippetError = false
  let snippetChanged = false

  // if we selected new requestBody or if we do not have httpSNippet yet, we need to re-init it
  if (!snippet.value ||
    newValue.serverUrl !== oldValue?.serverUrl ||
    newValue.requestPath !== oldValue?.requestPath ||
    newValue.requestQuery !== oldValue?.requestQuery ||
    newValue.authQuery !== oldValue?.authQuery ||
    newValue.requestBody !== oldValue?.requestBody ||
    newValue.authHeaders !== oldValue?.authHeaders ||
    newValue.customHeaders !== oldValue?.customHeaders) {

    // TODO: handle body change gracefully

    try {

      let serverUrl = new URL((newValue.serverUrl + newValue.requestPath).replaceAll('{', '').replaceAll('}', ''))
      let queryStr = newValue.requestQuery
      if (newValue.authQuery) {
        queryStr += (newValue.requestQuery ? '&' : '?') + newValue.authQuery
      }
      const headers = [
        ...getRequestHeaders(props.data),
        ...newValue.customHeaders,
        ...newValue.authHeaders,
      ]

      // returns json or formencoded body based on content-type header, we need to provide headers as an plain object key = header name, value: header value
      const { body } = getFormattedBody(headers.reduce((acc, current) => {
        acc[ current.name ] = current.value; return acc
      }, {}), newValue.requestBody)

      serverUrl.search = queryStr

      // for HTTPSnippet we need to provide query as an array of {name, value} objects
      const qObj = Object.fromEntries(serverUrl.searchParams)
      const qObjArr = Object.keys(qObj).map(p=>{
        return { name: p, value: qObj[p] }
      })

      // preparing reqData for HTTPSnipped as prescribed in https://github.com/Kong/httpsnippet/blob/master/README.md?plain=1#L113
      const reqData = ({
        method: newValue.method.toUpperCase(),
        // serverURL is coming from `new URL` so the parts are normalized as they should be , origin never doesn't have trading slash, and pathname always has a leading slash.
        // so we can just do simple concat here, and don't worry about missing/extra slashes
        url: serverUrl.origin + serverUrl.pathname,
        queryString: qObjArr,
        headers,
        postData: {
          // HTTPsnippet is not doing nice trying to handle with body params based on mimeType, so we going to send pre-formatted body, and
          // make HTTPsnippet to use as is by forcing mimeType as `text/plain`
          mimeType: 'text/plain',
          text:  body,
        },

      } as unknown as HarRequest)

      snippet.value = new HTTPSnippet(reqData)

      snippetChanged = true
    } catch (err) {
      console.error('@kong/spec-renderer: error in HTTPSnippet', err)
      snippetError = true
    }
  }
  if (snippetError) {
    requestCode.value = 'Error initializing code snippet'
  } else {
    // if we do not have requestCode generated, or our lang or lib are changed - we need to re-generate requestCode
    if (!requestCode.value || snippetChanged || newValue.lang !== oldValue?.lang || newValue.lib !== oldValue?.lib) {
      if (newValue.lang === 'json') {
        requestCode.value = newValue.requestBody
        return requestSampleConfigs.filter(c => c.httpSnippetLanguage !== 'json')
      } else if (snippet.value) {
        requestCode.value = snippet.value.convert((newValue.lang as TargetId), newValue.lib) || ''
      }
    }
  }
}, { immediate: true, deep: true })
</script>

<style lang="scss" scoped>

.request-sample-wrapper {
  .select-wrapper {
    display: flex;
    flex: 1;
    flex-wrap: wrap;
    gap: var(--kui-space-50, $kui-space-50);
    justify-content: space-between;

    .language-selector {
      :deep(.trigger-button) {
        padding-bottom: var(--kui-space-20, $kui-space-20);
        padding-top: var(--kui-space-20, $kui-space-20);
      }
    }

    .request-sample-selector {
      place-self: center;

      :deep(.trigger-button) {
        @include small-bordered-trigger-button;

        // fixing mixed-decls deprecation: https://sass-lang.com/d/mixed-decls
        // stylelint-disable-next-line no-duplicate-selectors
        * {
          @include truncate;
        }

        // fixing mixed-decls deprecation: https://sass-lang.com/d/mixed-decls
        // stylelint-disable-next-line no-duplicate-selectors
        * {
          max-width: 25ch;
        }

        @media (min-width: $kui-breakpoint-mobile) {
          max-width: 40ch;
        }
      }
    }
  }

  :deep(.panel-body .wide) {
    margin: var(--kui-space-0, $kui-space-0);
  }

  :deep(.required-only-wrapper) {
    label {
      margin-left: var(--kui-space-10, $kui-space-10) !important;
    }
  }

  :deep(.code-block pre) {
    border-bottom-left-radius: var(--kui-border-radius-30, $kui-border-radius-30);
    border-bottom-right-radius: var(--kui-border-radius-30, $kui-border-radius-30);
    border-top-left-radius: var(--kui-border-radius-0, $kui-border-radius-0);
    border-top-right-radius: var(--kui-border-radius-0, $kui-border-radius-0);
  }
}
</style>
